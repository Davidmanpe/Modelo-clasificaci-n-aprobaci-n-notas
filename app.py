import joblib
import streamlit as st
import pandas as pd

# Load the saved assets (one-hot encoder, min-max scaler, and the best stacking model)
try:
    onehot_encoder = joblib.load('onehot_encoder.joblib')
    minmax_scaler = joblib.load('minmax_scaler.joblib')
    best_stacking_model = joblib.load('best_stacking_model.joblib')
except FileNotFoundError:
    st.error("Error loading model or scalers. Please ensure the files are in the correct path in your Google Drive.")
    st.stop()
except Exception as e:
    st.error(f"An error occurred while loading assets: {e}")
    st.stop()


# Define the Streamlit app
st.title('Course Approval Prediction App')

st.write("""
This application predicts course approval based on student's Felder learning style and university entrance exam score.
""")

# Get user input
st.header('Enter Student Information')

felder_options = ['activo', 'visual', 'equilibrio', 'intuitivo', 'reflexivo', 'secuencial', 'sensorial', 'verbal'] # Replace with actual categories from your one-hot encoder if different
felder_input = st.selectbox('Select Felder Learning Style:', felder_options)

examen_admision_input = st.number_input('Enter University Entrance Exam Score:', min_value=0.0, max_value=10.0, step=0.01)


# Preprocess user input
if st.button('Predict Approval'):
    # Create a DataFrame from user input
    input_data = pd.DataFrame({
        'Felder': [felder_input],
        'Examen_admisión_Universidad': [examen_admision_input]
    })

    # Apply one-hot encoding to 'Felder'
    try:
        felder_encoded = onehot_encoder.transform(input_data[['Felder']])
        felder_encoded_df = pd.DataFrame(felder_encoded, columns=onehot_encoder.get_feature_names_out(['Felder']))
    except Exception as e:
        st.error(f"Error during one-hot encoding: {e}")
        st.stop()

    # Apply min-max scaling to 'Examen_admisión_Universidad'
    try:
        examen_admision_scaled = minmax_scaler.transform(input_data[['Examen_admisión_Universidad']])
        input_data['Examen_admisión_Universidad_scaled'] = examen_admision_scaled[:, 0] # Extract the scaled value
    except Exception as e:
        st.error(f"Error during min-max scaling: {e}")
        st.stop()


    # Prepare data for prediction (ensure column order matches training data)
    # Create a DataFrame with all possible one-hot encoded columns initialized to 0
    all_felder_cols = [col for col in onehot_encoder.get_feature_names_out(['Felder'])]
    prediction_data = pd.DataFrame(0.0, index=[0], columns=all_felder_cols)

    # Populate the one-hot encoded columns with the user's input
    for col in felder_encoded_df.columns:
        if col in prediction_data.columns:
            prediction_data[col] = felder_encoded_df[col]

    # Add the scaled exam score
    prediction_data['Examen_admisión_Universidad_scaled'] = input_data['Examen_admisión_Universidad_scaled']

    # Ensure the columns are in the same order as the training data if necessary.
    # You might need to save the column order of your training data and reindex here.
    # For now, assuming the order generated by get_feature_names_out() + scaled column is correct.


    # Make prediction
    try:
        prediction = best_stacking_model.predict(prediction_data)
        prediction_proba = best_stacking_model.predict_proba(prediction_data) # Optional: get probabilities

        st.header('Prediction Result')
        if prediction[0] == 'si': # Replace 'si' with your positive class label
            st.success('Predicted Approval: Yes')
        else:
            st.error('Predicted Approval: No')

        # Optional: Display probabilities
        # st.write(f"Prediction Probabilities: {prediction_proba}")

    except Exception as e:
        st.error(f"Error during prediction: {e}")
